#if 0
#include <iostream>
using namespace std;

// 观察者
// 发布订阅
/*
观察者模式和发布-订阅模式最大的区别： 发布-订阅模式有事件调度中心。
观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，这种处理方式可能会造成代码的冗余。
发布-订阅模式中，统一由调度中进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，另一方面可以实现更加细粒度的控制。比如发布者发布了很多消息，但不是所有的订阅者都希望接收到，就可以在调度中心做一些处理，类似权限控制之类的。还可以做一些节流操作。

如果以结构来分辨模式，发布-订阅模式比观察者模式多了一个调度中心，所以发布-订阅模式不同于观察者模式。
如果以意图来分辨模式，它们都实现了对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知，并自动更新，那么它们就是同一种模式，发布-订阅模式是在观察者模式的基础上做了优化升级。
不过不管它们是不是同一个设计模式，它们的实现方式的确是有区别，我们在使用时应该根据应用场景来判断选择哪个。
*/

int main()
{
	return 0;
}
#endif