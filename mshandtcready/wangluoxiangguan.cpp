//tcp
/*
三次握手：
流程：
问题：
1. 为什么需要3次：
Ⅰ服务器回的包因为网络延时等原因未按时到达客户端，此时客户端
会按超时处理，此时服务端不知道客户端收没收到确认信息。客户端超时
重传服务端会重新开启端口监听(服务端被动)，严重浪费端口资源
Ⅱ还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到
了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。

所以我们需要“第三次握手”来确认这个过程，让客户端和服务器端能够及
时地察觉到因为网络等一些问题导致的连接创建失败，这样服务器端的端
口就可以关闭了不用一直等待。
也可以这样理解：“第三次握手”是客户端向服务器端发送数据，这个数据
就是要告诉服务器，客户端有没有收到服务器“第二次握手”时传过去的数
据。若发送的这个数据是“收到了”的信息，接收后服务器就正常建立TCP连
接，否则建立TCP连接失败，服务器关闭连接端口。由此减少服务器开销和
接收到失效请求发生的错误。
四次挥手：
2MSL:
原因一：保证TCP全双工连接的可靠释放
解析：假设场景为客户端主动向服务器发起断开连接，假如在主动方（客户端）最后一次发送的ACK在网络中丢失，根据TCP的超时重传机制，
被动方（服务器）需要重新向客户端发送FIN + ACK，在FIN未达到之前，必须维护这条连接；并且要接收到客户端发出的ACK确认后才能终止
连接；如果直接在重传的FIN到达之前而关闭连接，当FIN到达后会促使客户端TCP传输层发送RST重新建立连接，而本质上这是一个正常断开连接的过程。
另一种解释是：
4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来；若主动关闭方能够保持一个2MS
L的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。
原因二：为了使就得数据包在网络中因过期而失效
解析：假设没有time_wait状态时，A刚刚与B断开连接，C又以和A相同的ip和port和B建立起连接，TCP协议栈无法区分A和C是不同的连接， 
这时，A连接发送的数据到达B之后会被B的TCP传输层当做当下正常的连接发来的数据进行处理，实际上这时上一条连接的脏数据；所以在
time_wait等待2MSL（报文在网络最大生存时间），将此连接的数据全部收到并丢弃，才能保证这些数据不会造成错误；
为什么是两个2MSL的原因：如果不到2MSL就断开连接，新连接又以旧连接相同的端口和ip连接服务器，就连接的重复数据报到达又会干扰第二个连接；
问题拓展：为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
答：这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到
对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也
可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。
*/
